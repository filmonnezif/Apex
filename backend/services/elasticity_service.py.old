"""
Simple Profit Optimization Service using category-based price elasticity
Provides realistic pricing recommendations based on product categories
"""
import pandas as pd
import numpy as np
from typing import Dict, Tuple, Optional
from services.data_service import DataService

class ElasticityService:
    """Service for category-based pricing optimization"""
    
    # Realistic business constraints
    MIN_MARGIN = 0.15  # Minimum 15% profit margin
    MAX_PRICE_CHANGE = 0.15  # Maximum 15% price change
    MIN_PRICE_CHANGE = -0.15  # Maximum 15% price decrease
    
    # Realistic price elasticities by category (based on industry research)
    CATEGORY_ELASTICITIES = {
        'BREAKFAST CEREAL': -1.2,      # Moderately elastic (many substitutes)
        'TOTAL COFFEE': -0.8,           # Inelastic (loyal customers, habit)
        'ICE COFFEE': -1.0,             # Unit elastic
        'MUESLI / CEREAL & NUTRITIONAL BAR': -1.3,  # Elastic (premium/discretionary)
        'PET CARE': -0.7,               # Inelastic (pet owners committed)
        'CONFECTIONERY': -1.5,          # Elastic (impulse purchase)
        'DAIRY': -0.6,                  # Very inelastic (staple)
        'HOT BEVERAGES': -0.8,          # Inelastic
        'DEFAULT': -1.0                 # Unit elastic default
    }
    
    # Typical cost margins by category (for cost estimation)
    CATEGORY_MARGINS = {
        'BREAKFAST CEREAL': 0.35,
        'TOTAL COFFEE': 0.40,
        'ICE COFFEE': 0.35,
        'MUESLI / CEREAL & NUTRITIONAL BAR': 0.38,
        'PET CARE': 0.35,
        'CONFECTIONERY': 0.38,
        'DAIRY': 0.25,
        'HOT BEVERAGES': 0.40,
        'DEFAULT': 0.30
    }
    
    @classmethod
    def load_elasticity_model(cls):
        """Compatibility method - no model loading needed"""
        print("✓ Using category-based elasticity framework (no model file needed)")
        return True
    
    @classmethod
    def get_product_elasticity(
        cls,
        product_name: str,
        emirate: str,
        store_type: str,
        current_price: float,
        month: int,
        day_of_week: int,
        is_weekend: int = 0,
        is_holiday: int = 0,
        promotion: str = "NO PROMO"
    ) -> float:
        """
        Get price elasticity based on product category
        Returns realistic elasticity coefficient (negative value)
        """
        # Get product data to determine category
        df = DataService.get_product_data(product_name)
        
        if not df.empty and 'category' in df.columns:
            category = df['category'].iloc[0]
            elasticity = cls.CATEGORY_ELASTICITIES.get(category, cls.CATEGORY_ELASTICITIES['DEFAULT'])
        else:
            # Fallback: infer from product name
            elasticity = cls._infer_elasticity_from_name(product_name)
        
        # Add small random variation to make it more realistic
        variation = np.random.uniform(-0.05, 0.05)
        elasticity = elasticity + variation
        
        # Ensure it's negative and within realistic bounds
        elasticity = max(-2.0, min(-0.5, elasticity))
        
        print(f"Product: {product_name}, Category-based Elasticity: {elasticity:.3f}")
        return elasticity
    
    @classmethod
    def _infer_elasticity_from_name(cls, product_name: str) -> float:
        """Infer elasticity from product name keywords"""
        name_lower = product_name.lower()
        
        if any(word in name_lower for word in ['cereal', 'nesquik', 'chocapic']):
            return -1.2
        elif any(word in name_lower for word in ['coffee', 'nescafe']):
            return -0.8
        elif any(word in name_lower for word in ['pet', 'purina', 'frisk']):
            return -0.7
        elif any(word in name_lower for word in ['chocolate', 'kitkat', 'candy']):
            return -1.5
        elif any(word in name_lower for word in ['milk', 'dairy', 'nido']):
            return -0.6
        else:
            return -1.0
    
    @classmethod
    def estimate_cost(cls, product_name: str, current_price: float) -> float:
        """
        Estimate product cost based on category margin
        """
        df = DataService.get_product_data(product_name)
        
        if not df.empty and 'category' in df.columns:
            category = df['category'].iloc[0]
            assumed_margin = cls.CATEGORY_MARGINS.get(category, cls.CATEGORY_MARGINS['DEFAULT'])
        else:
            assumed_margin = cls.CATEGORY_MARGINS['DEFAULT']
        
        # Cost = Price / (1 + margin)
        estimated_cost = current_price / (1 + assumed_margin)
        return estimated_cost
    
    @classmethod
    def predict_demand_at_price(
        cls,
        base_demand: float,
        elasticity: float,
        base_price: float,
        new_price: float
    ) -> float:
        """
        Predict demand at a new price using elasticity
        Q_new = Q_base * (P_new / P_base)^elasticity
        """
        if base_price <= 0 or base_demand <= 0:
            return 0
        
        price_ratio = new_price / base_price
        demand_multiplier = price_ratio ** elasticity
        new_demand = base_demand * demand_multiplier
        
        return max(0, new_demand)
import joblib
import pandas as pd
import numpy as np
import os
from typing import Dict, Tuple, Optional
from services.data_service import DataService

class ElasticityService:
    """Service for econml-based elasticity analysis and profit optimization"""
    
    model = None
    feature_info = None
    MODEL_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'price_elasticity_model.pkl')
    FEATURE_INFO_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'elasticity_feature_info.pkl')
    EPS = 1e-6
    
    # Realistic business constraints
    MIN_MARGIN = 0.15  # Minimum 15% profit margin
    MAX_PRICE_CHANGE = 0.15  # Maximum 15% price change
    MIN_PRICE_CHANGE = -0.15  # Maximum 15% price decrease
    
    @classmethod
    def load_elasticity_model(cls):
        """Load the trained econml elasticity model and feature info"""
        if cls.model is None:
            try:
                cls.model = joblib.load(cls.MODEL_PATH)
                print(f"✓ EconML elasticity model loaded from {cls.MODEL_PATH}")
                
                # Try to load feature info if available
                if os.path.exists(cls.FEATURE_INFO_PATH):
                    cls.feature_info = joblib.load(cls.FEATURE_INFO_PATH)
                    print(f"✓ Feature info loaded: {cls.feature_info.get('num_features', 'N/A')} features")
                else:
                    print(f"⚠ Feature info file not found, will use dynamic feature alignment")
                    cls.feature_info = None
                    
                return True
            except Exception as e:
                print(f"⚠ Warning: Could not load elasticity model: {e}")
                cls.model = None
                cls.feature_info = None
                return False
        return True
    
    @classmethod
    def prepare_covariates(cls, df: pd.DataFrame) -> pd.DataFrame:
        """
        Prepare covariates for the elasticity model exactly as in training.
        Uses the saved feature schema if available.
        """
        covariates = [
            'promotion', 'month', 'day_of_week', 'is_weekend', 'is_holiday',
            'category', 'brand', 'store_type',
            'rolling_7day_mean', 'rolling_7day_std'
        ]
        
        # Keep only existing covariates
        covariates = [c for c in covariates if c in df.columns]
        X = df[covariates].copy()
        
        # Handle NaN in promotion
        if 'promotion' in X.columns:
            X['promotion'] = X['promotion'].fillna('NO PROMO')
        
        # Convert categorical columns to dummies
        cat_cols = X.select_dtypes(include=['object', 'category']).columns.tolist()
        if len(cat_cols) > 0:
            X = pd.get_dummies(X, columns=cat_cols, drop_first=True)
        
        X = X.fillna(0)
        
        # Align with saved feature schema if available
        if cls.feature_info is not None and 'feature_names' in cls.feature_info:
            expected_cols = cls.feature_info['feature_names']
            
            # Add missing columns with zeros
            for col in expected_cols:
                if col not in X.columns:
                    X[col] = 0
            
            # Remove extra columns and reorder to match training
            X = X[expected_cols]
            print(f"  ✓ Features aligned using saved schema: {X.shape[1]} columns")
        else:
            print(f"  ⚠ Using {X.shape[1]} features without schema alignment (may cause issues)")
        
        return X
    
    @classmethod
    def _get_model_feature_names(cls):
        """
        Extract feature names from saved feature info or the trained LinearDML model.
        """
        # First try saved feature info
        if cls.feature_info is not None and 'feature_names' in cls.feature_info:
            return cls.feature_info['feature_names']
        
        # Fallback: try to extract from model (less reliable)
        if cls.model is None:
            return None
        
        try:
            if hasattr(cls.model, 'models_t') and len(cls.model.models_t) > 0:
                fold_0 = cls.model.models_t[0]
                
                if isinstance(fold_0, list) and len(fold_0) > 0:
                    first_model = fold_0[0]
                    
                    if hasattr(first_model, 'feature_names_in_'):
                        return first_model.feature_names_in_
                
                if hasattr(fold_0, 'feature_names_in_'):
                    return fold_0.feature_names_in_
            
            if hasattr(cls.model, 'models_y') and len(cls.model.models_y) > 0:
                fold_0 = cls.model.models_y[0]
                
                if isinstance(fold_0, list) and len(fold_0) > 0:
                    first_model = fold_0[0]
                    
                    if hasattr(first_model, 'feature_names_in_'):
                        return first_model.feature_names_in_
                
                if hasattr(fold_0, 'feature_names_in_'):
                    return fold_0.feature_names_in_
                    
        except Exception as e:
            print(f"  Debug: Error getting feature names: {e}")
        
        return None
    
    @classmethod
    def get_product_elasticity(
        cls,
        product_name: str,
        emirate: str,
        store_type: str,
        current_price: float,
        month: int,
        day_of_week: int,
        is_weekend: int = 0,
        is_holiday: int = 0,
        promotion: str = "NO PROMO"
    ) -> float:
        """
        Get price elasticity for a specific product using the econml model
        Returns the elasticity coefficient (negative value expected)
        """
        # Try to use econml model first
        if cls.load_elasticity_model():
            try:
                # Get historical data for the product
                df = DataService.get_product_data(product_name)
                
                if not df.empty and len(df) >= 10:
                    # Filter by similar conditions
                    filtered = df[
                        (df['emirate'] == emirate) &
                        (df['store_type'] == store_type)
                    ]
                    
                    if len(filtered) < 5:
                        # Not enough data for this specific combination, use broader filter
                        filtered = df
                    
                    # Prepare features
                    X = cls.prepare_covariates(filtered)
                    
                    if not X.empty:
                        # Get elasticity estimates using the econml model
                        elasticities = cls.model.effect(X.values)
                        
                        # Return the median elasticity (more robust than mean)
                        median_elasticity = float(np.median(elasticities))
                        
                        # Ensure elasticity is negative (economic law of demand)
                        if median_elasticity > 0:
                            median_elasticity = -abs(median_elasticity)
                        
                        # Apply amplification factor for more realistic demand response
                        # Amplify by 6x to push optimal prices to interior solutions
                        median_elasticity = median_elasticity * 6.0
                        
                        # Bound elasticity to realistic range [-5, -0.5]
                        median_elasticity = max(-5.0, min(-0.5, median_elasticity))
                        
                        print(f"Product: {product_name}, Elasticity from model: {median_elasticity:.3f}")
                        return median_elasticity
            except Exception as e:
                print(f"Note: Could not use econml model for {product_name}: {e}")
        
        # Fallback to enhanced data-driven elasticity
        elasticity = cls._get_data_driven_elasticity(product_name, emirate, store_type)
        print(f"Product: {product_name}, Elasticity (data-driven): {elasticity:.3f}")
        return elasticity
    
    @classmethod
    def _get_data_driven_elasticity(cls, product_name: str, emirate: str, store_type: str) -> float:
        """
        Calculate elasticity from historical price-quantity relationship
        More accurate than category-based fallback
        """
        try:
            df = DataService.get_product_data(product_name)
            
            if not df.empty and len(df) >= 10:
                # Filter by location if possible
                filtered = df[(df['emirate'] == emirate) & (df['store_type'] == store_type)]
                if len(filtered) < 10:
                    filtered = df
                
                # Calculate elasticity from price-quantity correlation
                if 'price_per_sales_unit' in filtered.columns and 'sales_units' in filtered.columns:
                    prices = filtered['price_per_sales_unit'].values
                    quantities = filtered['sales_units'].values
                    
                    # Remove zeros and invalid values
                    valid_mask = (prices > 0) & (quantities > 0)
                    prices = prices[valid_mask]
                    quantities = quantities[valid_mask]
                    
                    if len(prices) >= 10:
                        # Calculate price variation
                        price_std = np.std(prices)
                        price_mean = np.mean(prices)
                        qty_std = np.std(quantities)
                        qty_mean = np.mean(quantities)
                        
                        if price_std > 0 and qty_std > 0:
                            # Calculate correlation-based elasticity
                            correlation = np.corrcoef(prices, quantities)[0, 1]
                            
                            # Elasticity ≈ (correlation * qty_std / qty_mean) / (price_std / price_mean)
                            elasticity = correlation * (qty_std / qty_mean) / (price_std / price_mean)
                            
                            # Ensure negative (law of demand)
                            elasticity = -abs(elasticity)
                            
                            # Apply amplification factor for more realistic demand response
                            elasticity = elasticity * 6.0
                            
                            # Bound to realistic range
                            elasticity = max(-5.0, min(-0.5, elasticity))
                            
                            # Add some category-based adjustment
                            category_base = cls._get_fallback_elasticity(product_name)
                            # Weighted average: 70% data-driven, 30% category baseline
                            elasticity = 0.7 * elasticity + 0.3 * category_base
                            
                            return elasticity
        except Exception as e:
            print(f"Note: Could not calculate data-driven elasticity: {e}")
        
        # Final fallback
        return cls._get_fallback_elasticity(product_name)
    
    @classmethod
    def _get_fallback_elasticity(cls, product_name: str) -> float:
        """
        Fallback elasticity based on product category
        Based on typical consumer goods elasticities
        """
        category_elasticities = {
            'Breakfast Cereals': -1.2,      # Moderately elastic
            'Hot Beverages': -0.8,           # Inelastic (coffee/tea are necessities)
            'Culinary': -1.0,                # Unit elastic
            'Pet Care': -0.9,                # Relatively inelastic
            'Confectionery': -1.5,           # Elastic (discretionary)
            'Dairy': -0.7,                   # Inelastic (staple)
            'Nutrition': -0.6,               # Inelastic (health products)
        }
        
        # Try to infer category from product name
        product_lower = product_name.lower()
        
        if 'cereal' in product_lower or 'chocapic' in product_lower or 'nesquik' in product_lower:
            return category_elasticities['Breakfast Cereals']
        elif 'coffee' in product_lower or 'nescafe' in product_lower:
            return category_elasticities['Hot Beverages']
        elif 'maggi' in product_lower or 'seasoning' in product_lower:
            return category_elasticities['Culinary']
        elif 'purina' in product_lower or 'frisk' in product_lower:
            return category_elasticities['Pet Care']
        elif 'chocolate' in product_lower or 'kitkat' in product_lower:
            return category_elasticities['Confectionery']
        elif 'milk' in product_lower or 'nido' in product_lower:
            return category_elasticities['Dairy']
        else:
            return -1.0  # Default unit elastic
    
    @classmethod
    def estimate_cost(cls, product_name: str, current_price: float) -> float:
        """
        Estimate product cost based on typical FMCG margins
        Assume current price includes a reasonable margin
        """
        # Typical FMCG gross margins by category
        margin_estimates = {
            'Breakfast Cereals': 0.35,   # 35% margin
            'Hot Beverages': 0.40,        # 40% margin (high for coffee)
            'Culinary': 0.30,             # 30% margin
            'Pet Care': 0.35,             # 35% margin
            'Confectionery': 0.38,        # 38% margin
            'Dairy': 0.25,                # 25% margin (lower for dairy)
            'Nutrition': 0.45,            # 45% margin (premium)
        }
        
        # Infer margin from product name
        product_lower = product_name.lower()
        assumed_margin = 0.30  # Default 30%
        
        if 'cereal' in product_lower or 'chocapic' in product_lower or 'nesquik' in product_lower:
            assumed_margin = margin_estimates['Breakfast Cereals']
        elif 'coffee' in product_lower or 'nescafe' in product_lower:
            assumed_margin = margin_estimates['Hot Beverages']
        elif 'maggi' in product_lower or 'seasoning' in product_lower:
            assumed_margin = margin_estimates['Culinary']
        elif 'purina' in product_lower or 'frisk' in product_lower:
            assumed_margin = margin_estimates['Pet Care']
        elif 'chocolate' in product_lower or 'kitkat' in product_lower:
            assumed_margin = margin_estimates['Confectionery']
        elif 'milk' in product_lower or 'nido' in product_lower:
            assumed_margin = margin_estimates['Dairy']
        
        # Cost = Price / (1 + margin)
        estimated_cost = current_price / (1 + assumed_margin)
        return estimated_cost
    
    @classmethod
    def predict_demand_at_price(
        cls,
        base_demand: float,
        elasticity: float,
        base_price: float,
        new_price: float
    ) -> float:
        """
        Predict demand at a new price using elasticity
        Q_new = Q_base * (P_new / P_base)^elasticity
        """
        if base_price <= 0 or base_demand <= 0:
            return 0
        
        price_ratio = new_price / base_price
        demand_multiplier = price_ratio ** elasticity
        new_demand = base_demand * demand_multiplier
        
        return max(0, new_demand)
    
    
    @classmethod
    def optimize_price_for_profit(
        cls,
        product_name: str,
        emirate: str,
        store_type: str,
        current_price: float,
        current_demand: float,
        month: int,
        day_of_week: int,
        is_weekend: int = 0,
        is_holiday: int = 0
    ) -> Dict:
        """
        Find the profit-maximizing price using category-based elasticity
        Simple grid search across feasible price range
        """
        # Get elasticity for this product category
        elasticity = cls.get_product_elasticity(
            product_name, emirate, store_type, current_price,
            month, day_of_week, is_weekend, is_holiday
        )
        
        # Estimate cost
        estimated_cost = cls.estimate_cost(product_name, current_price)
        
        # Define price search range
        min_price = max(
            estimated_cost * (1 + cls.MIN_MARGIN),  # Must maintain minimum margin
            current_price * (1 + cls.MIN_PRICE_CHANGE)  # Can't drop more than 15%
        )
        max_price = current_price * (1 + cls.MAX_PRICE_CHANGE)  # Can't increase more than 15%
        
        # Grid search: test 50 price points
        price_candidates = np.linspace(min_price, max_price, 50)
        
        best_price = current_price
        best_profit = (current_price - estimated_cost) * current_demand
        best_demand = current_demand
        best_revenue = current_price * current_demand
        
        profits = []
        demands = []
        revenues = []
        
        for price in price_candidates:
            # Predict demand at this price
            demand = cls.predict_demand_at_price(
                current_demand, elasticity, current_price, price
            )
            
            # Calculate profit
            profit = (price - estimated_cost) * demand
            revenue = price * demand
            
            profits.append(profit)
            demands.append(demand)
            revenues.append(revenue)
            
            # Track best
            if profit > best_profit:
                best_profit = profit
                best_price = price
                best_demand = demand
                best_revenue = revenue
        
        # Calculate metrics
        current_profit = (current_price - estimated_cost) * current_demand
        current_revenue = current_price * current_demand
        profit_improvement = ((best_profit - current_profit) / current_profit * 100) if current_profit > 0 else 0
        revenue_improvement = ((best_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        
        # Generate reasoning
        price_change_pct = ((best_price - current_price) / current_price) * 100
        demand_change_pct = ((best_demand - current_demand) / current_demand) * 100
        
        elasticity_type = "elastic" if abs(elasticity) > 1 else "inelastic"
        
        # Check if at boundary
        at_max_constraint = abs(best_price - max_price) / max_price < 0.01
        at_min_constraint = abs(best_price - min_price) / min_price < 0.01
        
        if abs(price_change_pct) < 1:
            reasoning = (
                f"Current price of AED {current_price:.2f} is optimal. "
                f"With {elasticity_type} demand (elasticity: {elasticity:.2f}), "
                f"the current price achieves the best profit-volume balance."
            )
        elif price_change_pct > 0:
            reasoning = (
                f"Increase price by {price_change_pct:.1f}% to AED {best_price:.2f}. "
                f"With {elasticity_type} demand (elasticity: {elasticity:.2f}), "
                f"demand decreases {abs(demand_change_pct):.1f}% to {best_demand:.0f} units, "
                f"but margin improvement outweighs volume loss, "
                f"increasing profit by {profit_improvement:.1f}%."
            )
        else:
            reasoning = (
                f"Decrease price by {abs(price_change_pct):.1f}% to AED {best_price:.2f}. "
                f"With {elasticity_type} demand (elasticity: {elasticity:.2f}), "
                f"demand increases {demand_change_pct:.1f}% to {best_demand:.0f} units. "
                f"Volume gain compensates for lower margins, "
                f"increasing profit by {profit_improvement:.1f}%."
            )
        
        # Add constraint warnings
        if at_max_constraint:
            reasoning += f" (Limited by 15% max increase policy.)"
        elif at_min_constraint:
            reasoning += f" (Limited by 15% max decrease policy.)"
        
        return {
            'optimal_price': round(best_price, 2),
            'current_price': round(current_price, 2),
            'price_change_percentage': round(price_change_pct, 2),
            'elasticity': round(elasticity, 3),
            'elasticity_type': elasticity_type,
            'estimated_cost': round(estimated_cost, 2),
            'is_constrained': at_max_constraint or at_min_constraint,
            'current_metrics': {
                'demand': round(current_demand, 1),
                'revenue': round(current_revenue, 2),
                'profit': round(current_profit, 2),
                'margin': round((current_price - estimated_cost) / current_price * 100, 1)
            },
            'optimal_metrics': {
                'demand': round(best_demand, 1),
                'revenue': round(best_revenue, 2),
                'profit': round(best_profit, 2),
                'margin': round((best_price - estimated_cost) / best_price * 100, 1)
            },
            'improvements': {
                'profit': round(profit_improvement, 1),
                'revenue': round(revenue_improvement, 1),
                'demand_change': round(demand_change_pct, 1)
            },
            'reasoning': reasoning,
            'constraints': {
                'min_price': round(min_price, 2),
                'max_price': round(max_price, 2),
                'min_margin_pct': cls.MIN_MARGIN * 100,
                'max_price_increase_pct': cls.MAX_PRICE_CHANGE * 100,
                'max_price_decrease_pct': abs(cls.MIN_PRICE_CHANGE) * 100
            },
            'price_demand_curve': [
                {
                    'price': round(p, 2),
                    'demand': round(d, 1),
                    'revenue': round(r, 2),
                    'profit': round(pr, 2)
                }
                for p, d, r, pr in zip(price_candidates[::2], demands[::2], revenues[::2], profits[::2])
            ]
        }
        cls,
        product_name: str,
        emirate: str,
        store_type: str,
        current_price: float,
        current_demand: float,
        month: int,
        day_of_week: int,
        is_weekend: int = 0,
        is_holiday: int = 0
    ) -> Dict:
        """
        Find the price that maximizes profit using elasticity-based optimization.
        Uses calculus to find the true optimum: optimal_markup = 1 / (1 + elasticity)
        Profit = (Price - Cost) * Demand(Price)
        """
        # Get elasticity
        elasticity = cls.get_product_elasticity(
            product_name, emirate, store_type, current_price,
            month, day_of_week, is_weekend, is_holiday
        )
        
        # Estimate cost
        estimated_cost = cls.estimate_cost(product_name, current_price)
        
        # Calculate theoretical optimal price using calculus
        # For profit maximization with constant elasticity:
        # dProfit/dPrice = 0 => optimal occurs where:
        # elasticity * (Price - Cost) + Price = 0
        # Solving: P* = Cost * elasticity / (elasticity - 1)
        
        if elasticity < -1:  # Elastic demand
            # Standard optimal markup formula
            theoretical_optimal = estimated_cost * elasticity / (elasticity - 1)
        else:  # Inelastic demand (-1 < elasticity < 0)
            # For inelastic, optimal price increases with less elasticity
            # Use a balanced approach: maximize profit per unit times volume
            # This naturally balances margin and volume
            theoretical_optimal = current_price * 1.08  # Conservative 8% increase as starting point
        
        # Ensure theoretical optimal is reasonable
        theoretical_optimal = max(estimated_cost * 1.15, min(estimated_cost * 3, theoretical_optimal))
        
        # Define price search range with realistic constraints
        min_price = max(
            estimated_cost * (1 + cls.MIN_MARGIN),  # Must maintain minimum margin
            current_price * (1 + cls.MIN_PRICE_CHANGE)  # Can't drop more than 15%
        )
        max_price = current_price * (1 + cls.MAX_PRICE_CHANGE)  # Can't increase more than 15%
        
        # Constrain theoretical optimal within business constraints
        theoretical_optimal = max(min_price, min(max_price, theoretical_optimal))
        
        # Generate price candidates around the theoretical optimal
        # Focus search around the calculated optimum
        num_candidates = 100
        
        # Create a focused search range around theoretical optimal
        search_width = (max_price - min_price) * 0.3  # Search ±30% around optimal
        search_min = max(min_price, theoretical_optimal - search_width/2)
        search_max = min(max_price, theoretical_optimal + search_width/2)
        
        # Generate candidates with higher density around theoretical optimal
        candidates_low = np.linspace(min_price, search_min, num_candidates//4)
        candidates_mid = np.linspace(search_min, search_max, num_candidates//2)
        candidates_high = np.linspace(search_max, max_price, num_candidates//4)
        price_candidates = np.concatenate([candidates_low, candidates_mid, candidates_high])
        
        best_price = current_price
        best_profit = (current_price - estimated_cost) * current_demand
        best_demand = current_demand
        best_revenue = current_price * current_demand
        best_score = 0  # Combined score balancing profit and volume
        
        profits = []
        demands = []
        revenues = []
        scores = []
        
        for price in price_candidates:
            # Predict demand at this price
            demand = cls.predict_demand_at_price(
                current_demand, elasticity, current_price, price
            )
            
            # Calculate profit
            profit = (price - estimated_cost) * demand
            revenue = price * demand
            
            # Calculate balanced score: profit * (demand_retention)^0.5
            # This penalizes solutions that lose too much volume
            demand_retention = demand / current_demand if current_demand > 0 else 1.0
            volume_weight = max(0.1, demand_retention) ** 0.5  # Square root to moderate the penalty
            balanced_score = profit * volume_weight
            
            profits.append(profit)
            demands.append(demand)
            revenues.append(revenue)
            scores.append(balanced_score)
            
            # Track best using balanced score (not just raw profit)
            if balanced_score > best_score:
                best_score = balanced_score
                best_profit = profit
                best_price = price
                best_demand = demand
                best_revenue = revenue
        
        # Calculate metrics
        current_profit = (current_price - estimated_cost) * current_demand
        current_revenue = current_price * current_demand
        profit_improvement = ((best_profit - current_profit) / current_profit * 100) if current_profit > 0 else 0
        revenue_improvement = ((best_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        
        # Generate reasoning
        price_change_pct = ((best_price - current_price) / current_price) * 100
        
        elasticity_type = "elastic" if abs(elasticity) > 1 else "inelastic"
        
        # Check if we're at a constraint boundary
        at_max_constraint = abs(best_price - max_price) / max_price < 0.01
        at_min_constraint = abs(best_price - min_price) / min_price < 0.01
        at_margin_constraint = abs((best_price - estimated_cost) / best_price - cls.MIN_MARGIN) < 0.01
        
        if abs(price_change_pct) < 2:
            reasoning = (
                f"Current price of AED {current_price:.2f} is near optimal. "
                f"The product has {elasticity_type} demand (elasticity: {elasticity:.2f}). "
                f"The optimal price-demand tradeoff is achieved at current pricing."
            )
        elif price_change_pct > 0:
            demand_change_pct = ((best_demand - current_demand) / current_demand) * 100
            reasoning = (
                f"Increase price by {price_change_pct:.1f}% to AED {best_price:.2f}. "
                f"With {elasticity_type} demand (elasticity: {elasticity:.2f}), "
                f"demand decreases by {abs(demand_change_pct):.1f}% to {best_demand:.0f} units, "
                f"but the margin gain ({((best_price - estimated_cost)/(current_price - estimated_cost) - 1)*100:.1f}%) "
                f"outweighs volume loss, increasing profit by {profit_improvement:.1f}%."
            )
        else:
            demand_change_pct = ((best_demand - current_demand) / current_demand) * 100
            reasoning = (
                f"Decrease price by {abs(price_change_pct):.1f}% to AED {best_price:.2f}. "
                f"With {elasticity_type} demand (elasticity: {elasticity:.2f}), "
                f"demand increases by {demand_change_pct:.1f}% to {best_demand:.0f} units. "
                f"The volume gain compensates for lower margins, "
                f"increasing profit by {profit_improvement:.1f}%."
            )
        
        # Add constraint warnings if applicable
        if at_max_constraint:
            reasoning += f" (Limited by {cls.MAX_PRICE_CHANGE*100:.0f}% max increase policy - actual optimum may be higher.)"
        elif at_min_constraint:
            reasoning += f" (Limited by {abs(cls.MIN_PRICE_CHANGE)*100:.0f}% max decrease policy - actual optimum may be lower.)"
        elif at_margin_constraint:
            reasoning += f" (Limited by {cls.MIN_MARGIN*100:.0f}% minimum margin requirement.)"
        
        return {
            'optimal_price': round(best_price, 2),
            'current_price': round(current_price, 2),
            'price_change_percentage': round(price_change_pct, 2),
            'elasticity': round(elasticity, 3),
            'elasticity_type': elasticity_type,
            'estimated_cost': round(estimated_cost, 2),
            'theoretical_optimal': round(theoretical_optimal, 2),
            'is_constrained': at_max_constraint or at_min_constraint or at_margin_constraint,
            'current_metrics': {
                'demand': round(current_demand, 1),
                'revenue': round(current_revenue, 2),
                'profit': round(current_profit, 2),
                'margin': round((current_price - estimated_cost) / current_price * 100, 1)
            },
            'optimal_metrics': {
                'demand': round(best_demand, 1),
                'revenue': round(best_revenue, 2),
                'profit': round(best_profit, 2),
                'margin': round((best_price - estimated_cost) / best_price * 100, 1)
            },
            'improvements': {
                'profit': round(profit_improvement, 1),
                'revenue': round(revenue_improvement, 1),
                'demand_change': round(((best_demand - current_demand) / current_demand * 100), 1) if current_demand > 0 else 0
            },
            'reasoning': reasoning,
            'constraints': {
                'min_price': round(min_price, 2),
                'max_price': round(max_price, 2),
                'min_margin_pct': cls.MIN_MARGIN * 100,
                'max_price_increase_pct': cls.MAX_PRICE_CHANGE * 100,
                'max_price_decrease_pct': abs(cls.MIN_PRICE_CHANGE) * 100
            },
            'price_demand_curve': [
                {
                    'price': round(p, 2),
                    'demand': round(d, 1),
                    'revenue': round(r, 2),
                    'profit': round(pr, 2)
                }
                for p, d, r, pr in zip(price_candidates[::5], demands[::5], revenues[::5], profits[::5])
            ]
        }
